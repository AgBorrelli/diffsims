src/basis.c:					GTK_WINDOW(ctx->dw->window),
src/basis.c:					GTK_WINDOW(ctx->dw->window),
src/displaywindow.c:	GLfloat w = dw->drawing_area->allocation.width;
src/displaywindow.c:	GLfloat h = dw->drawing_area->allocation.height;
src/displaywindow.c:	dw->view = gtk_radio_action_get_current_value(action);
src/displaywindow.c:	if ( dw->view == DW_ORTHO ) {
src/displaywindow.c:	dw->mode = gtk_radio_action_get_current_value(action);
src/displaywindow.c:	dw->x_start = event->x;
src/displaywindow.c:	dw->y_start = event->y;
src/displaywindow.c:		dw->distance += event->y - dw->y_start;
src/displaywindow.c:		if ( dw->distance < 1.0 ) dw->distance = 1.0;
src/displaywindow.c:		if ( dw->distance > 310.0 ) dw->distance = 310.0;
src/displaywindow.c:		if ( dw->view == DW_ORTHO ) {
src/displaywindow.c:		dw->x_pos += (event->x - dw->x_start)/5;
src/displaywindow.c:		dw->y_pos += (event->y - dw->y_start)/5;
src/displaywindow.c:		trackball(d_quat, (2.0*dw->x_start - w)/w,
src/displaywindow.c:				  (h-2.0*dw->y_start)/h,
src/displaywindow.c:		add_quats(d_quat, dw->view_quat, dw->view_quat);
src/displaywindow.c:	dw->x_start = x;
src/displaywindow.c:	dw->y_start = y;
src/displaywindow.c:	dirax_invoke(dw->ctx);
src/displaywindow.c:	dirax_stop(dw->ctx);
src/displaywindow.c:	dirax_rerun(dw->ctx);
src/displaywindow.c:	dw->cube = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(widget));
src/displaywindow.c:	dw->lines = gtk_toggle_action_get_active(GTK_TOGGLE_ACTION(widget));
src/displaywindow.c:	dw->background = gtk_toggle_action_get_active(
src/displaywindow.c:	dw->savecache_window = gtk_file_chooser_dialog_new(
src/displaywindow.c:			"Save Image Analysis to Cache", GTK_WINDOW(dw->window),
src/displaywindow.c:	g_signal_connect(G_OBJECT(dw->savecache_window), "response",
src/displaywindow.c:				dw->ctx);
src/displaywindow.c:	gtk_widget_show_all(dw->savecache_window);
src/displaywindow.c:		offset = gtk_entry_get_text(GTK_ENTRY(dw->tiltaxis_entry));
src/displaywindow.c:		mapping_adjust_axis(dw->ctx, deg2rad(off));
src/displaywindow.c:	return displaywindow_setaxis_response(dw->tiltaxis_window,
src/displaywindow.c:	mapping_adjust_axis(dw->ctx, deg2rad(0.2));
src/displaywindow.c:	mapping_adjust_axis(dw->ctx, deg2rad(-0.2));
src/displaywindow.c:	dw->tiltaxis_window = gtk_dialog_new_with_buttons(
src/displaywindow.c:		"Set Tilt Axis Position", GTK_WINDOW(dw->window),
src/displaywindow.c:	gtk_box_pack_start(GTK_BOX(GTK_DIALOG(dw->tiltaxis_window)->vbox),
src/displaywindow.c:	dw->tiltaxis_entry = gtk_entry_new();
src/displaywindow.c:				  GTK_WIDGET(dw->tiltaxis_entry), 2, 3, 1, 2);
src/displaywindow.c:	gtk_entry_set_alignment(GTK_ENTRY(dw->tiltaxis_entry), 1);
src/displaywindow.c:	g_signal_connect(G_OBJECT(dw->tiltaxis_window), "response",
src/displaywindow.c:	g_signal_connect(G_OBJECT(dw->tiltaxis_entry), "activate",
src/displaywindow.c:	gtk_widget_show_all(dw->tiltaxis_window);
src/displaywindow.c:	gtk_widget_grab_focus(GTK_WIDGET(dw->tiltaxis_entry));
src/displaywindow.c:	dw->cur_image = 0;
src/displaywindow.c:	if ( dw->cur_image > 0 ) {
src/displaywindow.c:		dw->cur_image--;
src/displaywindow.c:	if ( dw->cur_image < dw->ctx->images->n_images-1 ) {
src/displaywindow.c:		dw->cur_image++;
src/displaywindow.c:	dw->cur_image = dw->ctx->images->n_images-1;
src/displaywindow.c:	refine_do_cell(dw->ctx);
src/displaywindow.c:	refine_do_sequence(dw->ctx);
src/displaywindow.c:	intensities_extract(dw->ctx);
src/displaywindow.c:	action = gtk_action_group_get_action(dw->action_group, "MappedAction");
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui, "/ui/displaywindow/file/savehkl");
src/displaywindow.c:	intensities_save(dw->ctx);
src/displaywindow.c:	basis_load(dw->ctx);
src/displaywindow.c:	basis_save(dw->ctx);
src/displaywindow.c:					dw->cube },
src/displaywindow.c:					dw->lines },
src/displaywindow.c:					dw->background },
src/displaywindow.c:	dw->action_group = gtk_action_group_new("dtrdisplaywindow");
src/displaywindow.c:	gtk_action_group_add_actions(dw->action_group, entries, n_entries, dw);
src/displaywindow.c:	gtk_action_group_add_radio_actions(dw->action_group, radios, n_radios,
src/displaywindow.c:	gtk_action_group_add_radio_actions(dw->action_group, radios2, n_radios2,
src/displaywindow.c:	gtk_action_group_add_toggle_actions(dw->action_group, toggles,
src/displaywindow.c:	dw->ui = gtk_ui_manager_new();
src/displaywindow.c:	gtk_ui_manager_insert_action_group(dw->ui, dw->action_group, 0);
src/displaywindow.c:	g_signal_connect(dw->ui, "add_widget",
src/displaywindow.c:			G_CALLBACK(displaywindow_addui_callback), dw->bigvbox);
src/displaywindow.c:	if ( gtk_ui_manager_add_ui_from_file(dw->ui,
src/displaywindow.c:	gtk_window_add_accel_group(GTK_WINDOW(dw->window),
src/displaywindow.c:					gtk_ui_manager_get_accel_group(dw->ui));
src/displaywindow.c:	gtk_ui_manager_ensure_update(dw->ui);
src/displaywindow.c:	if ( dw->ctx->images->n_images == 0 ) return;
src/displaywindow.c:	double ang = dw->ctx->images->images[dw->cur_image].tilt;
src/displaywindow.c:	imagedisplay_clear_marks(dw->stack);
src/displaywindow.c:	imagedisplay_put_data(dw->stack,
src/displaywindow.c:				dw->ctx->images->images[dw->cur_image]);
src/displaywindow.c:	image = &dw->ctx->images->images[dw->cur_image];
src/displaywindow.c:	if ( dw->ctx->cell_lattice ) {
src/displaywindow.c:							dw->ctx->cell_lattice);
src/displaywindow.c:			imagedisplay_add_mark(dw->stack,
src/displaywindow.c:			imagedisplay_add_mark(dw->stack, flist->features[j].x,
src/displaywindow.c:	if ( image->features && dw->ctx->cell_lattice ) {
src/displaywindow.c:				imagedisplay_add_line(dw->stack,
src/displaywindow.c:	if ( dw->cur_image == 0 ) {
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	} else if ( dw->cur_image == dw->ctx->images->n_images-1 ) {
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:		d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	if ( dw->realised && (page_num == 1) ) {
src/displaywindow.c:			glbits_expose(dw->drawing_area, NULL, dw);
src/displaywindow.c:	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(dw->messages));
src/displaywindow.c:	gtk_text_buffer_move_mark(buffer, dw->messages_mark, &iter);
src/displaywindow.c:	gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(dw->messages),
src/displaywindow.c:					dw->messages_mark, 0, TRUE, 1.0, 0.0);
src/displaywindow.c:	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(dw->messages));
src/displaywindow.c:	dw->ctx = ctx;
src/displaywindow.c:	dw->gl_use_buffers = 1;
src/displaywindow.c:	dw->gl_use_shaders = 1;
src/displaywindow.c:	dw->view = DW_ORTHO;
src/displaywindow.c:	dw->mode = DW_MAPPED;
src/displaywindow.c:	dw->distance = 150;
src/displaywindow.c:	dw->x_pos = 0;
src/displaywindow.c:	dw->y_pos = 0;
src/displaywindow.c:	dw->view_quat[0] = 0.0;
src/displaywindow.c:	dw->view_quat[1] = 0.0;
src/displaywindow.c:	dw->view_quat[2] = 0.0;
src/displaywindow.c:	dw->view_quat[3] = 1.0;
src/displaywindow.c:	dw->cube = TRUE;
src/displaywindow.c:	dw->lines = FALSE;
src/displaywindow.c:	dw->background = TRUE;
src/displaywindow.c:	dw->cur_image = 0;
src/displaywindow.c:	dw->realised = 0;
src/displaywindow.c:	dw->window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
src/displaywindow.c:	gtk_window_set_title(GTK_WINDOW(dw->window), title);
src/displaywindow.c:	dw->bigvbox = gtk_vbox_new(FALSE, 0);
src/displaywindow.c:	gtk_container_add(GTK_CONTAINER(dw->window), dw->bigvbox);
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->window), "destroy",
src/displaywindow.c:	gtk_box_pack_end(GTK_BOX(dw->bigvbox), notebook, TRUE, TRUE, 0);
src/displaywindow.c:	dw->messages = gtk_text_view_new();
src/displaywindow.c:	gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(dw->messages), GTK_WRAP_NONE);
src/displaywindow.c:				GTK_WIDGET(dw->messages));
src/displaywindow.c:	gtk_widget_modify_bg(dw->messages, GTK_STATE_NORMAL, &colour);
src/displaywindow.c:	buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(dw->messages));
src/displaywindow.c:	gtk_text_view_set_editable(GTK_TEXT_VIEW(dw->messages), FALSE);
src/displaywindow.c:	dw->messages_mark = gtk_text_buffer_create_mark(buffer, NULL, &iter,
src/displaywindow.c:	GTK_WIDGET_UNSET_FLAGS(dw->messages, GTK_CAN_FOCUS);
src/displaywindow.c:	gtk_container_set_reallocate_redraws(GTK_CONTAINER(dw->window), TRUE);
src/displaywindow.c:	dw->drawing_area = gtk_drawing_area_new();
src/displaywindow.c:	gtk_widget_set_size_request(dw->drawing_area, 640, 640);
src/displaywindow.c:	gtk_widget_set_gl_capability(dw->drawing_area, glconfig, NULL, TRUE,
src/displaywindow.c:	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), dw->drawing_area,
src/displaywindow.c:	gtk_widget_add_events(dw->drawing_area,
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "configure_event",
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "realize",
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "expose_event",
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "button_press_event",
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "motion_notify_event",
src/displaywindow.c:	g_signal_connect(GTK_OBJECT(dw->drawing_area), "destroy",
src/displaywindow.c:		dw->stack = imagedisplay_new_nowindow(
src/displaywindow.c:				ctx->images->images[dw->cur_image],
src/displaywindow.c:					dw->stack->vbox,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui, "/ui/displaywindow/file/savehkl");
src/displaywindow.c:	gtk_window_set_default_size(GTK_WINDOW(dw->window), 840, 800);
src/displaywindow.c:	gtk_widget_show_all(dw->window);
src/displaywindow.c:	gdk_window_invalidate_rect(dw->drawing_area->window,
src/displaywindow.c:					&dw->drawing_area->allocation, FALSE);
src/displaywindow.c:	start = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	stop = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	rerun = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	window = gtk_message_dialog_new(GTK_WINDOW(dw->window),
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/displaywindow.c:	d = gtk_ui_manager_get_widget(dw->ui,
src/glbits.c:	dw->gl_vshader_lightpp = glbits_load_shader(DATADIR"/dtr/light-pp.vert", GL_VERTEX_SHADER);
src/glbits.c:	dw->gl_fshader_lightpp = glbits_load_shader(DATADIR"/dtr/light-pp.frag", GL_FRAGMENT_SHADER);
src/glbits.c:	dw->gl_program_lightpp = glCreateProgram();
src/glbits.c:	glAttachShader(dw->gl_program_lightpp, dw->gl_vshader_lightpp);
src/glbits.c:	glAttachShader(dw->gl_program_lightpp, dw->gl_fshader_lightpp);
src/glbits.c:	glLinkProgram(dw->gl_program_lightpp);
src/glbits.c:	glDetachShader(dw->gl_program_lightpp, dw->gl_fshader_lightpp);
src/glbits.c:	glDetachShader(dw->gl_program_lightpp, dw->gl_vshader_lightpp);
src/glbits.c:	glDeleteShader(dw->gl_fshader_lightpp);
src/glbits.c:	glDeleteShader(dw->gl_program_lightpp);
src/glbits.c:	ctx = dw->ctx;
src/glbits.c:	if ( dw->gl_use_buffers ) {
src/glbits.c:		glGenBuffers(1, &dw->gl_ref_vertex_buffer);
src/glbits.c:		glGenBuffers(1, &dw->gl_ref_normal_buffer);
src/glbits.c:	dw->gl_ref_num_vertices = i;
src/glbits.c:	if ( dw->gl_ref_num_vertices ) {
src/glbits.c:		vertices = malloc(3*dw->gl_ref_num_vertices*sizeof(GLfloat));
src/glbits.c:		normals = malloc(3*dw->gl_ref_num_vertices*sizeof(GLfloat));
src/glbits.c:		if ( dw->gl_use_buffers ) {
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_ref_vertex_buffer);
src/glbits.c:			glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_ref_num_vertices*sizeof(GLfloat), vertices, GL_STATIC_DRAW);
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_ref_normal_buffer);
src/glbits.c:			glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_ref_num_vertices*sizeof(GLfloat), normals, GL_STATIC_DRAW);
src/glbits.c:			dw->gl_ref_vertex_array = vertices;
src/glbits.c:			dw->gl_ref_normal_array = normals;
src/glbits.c:	if ( dw->gl_use_buffers ) {
src/glbits.c:		glGenBuffers(1, &dw->gl_marker_vertex_buffer);
src/glbits.c:		glGenBuffers(1, &dw->gl_marker_normal_buffer);
src/glbits.c:	dw->gl_marker_num_vertices = i*VERTICES_IN_A_BLOB;
src/glbits.c:	if ( dw->gl_marker_num_vertices ) {
src/glbits.c:		vertices = malloc(3*dw->gl_marker_num_vertices*sizeof(GLfloat));
src/glbits.c:		normals = malloc(3*dw->gl_marker_num_vertices*sizeof(GLfloat));
src/glbits.c:		if ( dw->gl_use_buffers ) {
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_marker_vertex_buffer);
src/glbits.c:			glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_marker_num_vertices*sizeof(GLfloat), vertices, GL_STATIC_DRAW);
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_marker_normal_buffer);
src/glbits.c:			glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_marker_num_vertices*sizeof(GLfloat), normals, GL_STATIC_DRAW);
src/glbits.c:			dw->gl_marker_vertex_array = vertices;
src/glbits.c:			dw->gl_marker_normal_array = normals;
src/glbits.c:	if ( dw->gl_use_buffers ) {
src/glbits.c:		glGenBuffers(1, &dw->gl_gen_vertex_buffer);
src/glbits.c:		glGenBuffers(1, &dw->gl_gen_normal_buffer);
src/glbits.c:		dw->gl_gen_num_vertices = i*VERTICES_IN_A_BLOB;
src/glbits.c:		if ( dw->gl_gen_num_vertices ) {
src/glbits.c:			vertices = malloc(3*dw->gl_gen_num_vertices*sizeof(GLfloat));
src/glbits.c:			normals = malloc(3*dw->gl_gen_num_vertices*sizeof(GLfloat));
src/glbits.c:			if ( dw->gl_use_buffers ) {
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_gen_vertex_buffer);
src/glbits.c:				glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_gen_num_vertices*sizeof(GLfloat), vertices, GL_STATIC_DRAW);
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_gen_normal_buffer);
src/glbits.c:				glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_gen_num_vertices*sizeof(GLfloat), normals, GL_STATIC_DRAW);
src/glbits.c:				dw->gl_gen_vertex_array = vertices;
src/glbits.c:				dw->gl_gen_normal_array = normals;
src/glbits.c:		dw->gl_gen_num_vertices = 0;
src/glbits.c:	if ( ctx->cell && dw->lines ) {
src/glbits.c:		dw->gl_line_num_vertices = 3*2*((2*1+1)*(2*1+1));
src/glbits.c:		if ( dw->gl_use_buffers ) {
src/glbits.c:			glGenBuffers(1, &dw->gl_line_vertex_buffer);
src/glbits.c:		vertices = malloc(3*dw->gl_line_num_vertices*sizeof(GLfloat));
src/glbits.c:		if ( dw->gl_use_buffers ) {
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_line_vertex_buffer);
src/glbits.c:			glBufferData(GL_ARRAY_BUFFER, 3*dw->gl_line_num_vertices*sizeof(GLfloat), vertices, GL_STATIC_DRAW);
src/glbits.c:			dw->gl_line_vertex_array = vertices;
src/glbits.c:	dw->gl_list_id = glGenLists(1);
src/glbits.c:	glNewList(dw->gl_list_id, GL_COMPILE);
src/glbits.c:	if ( dw->cube ) {
src/glbits.c:	if ( ctx->cell && !dw->lines ) {
src/glbits.c:	//printf("DW: Vertex counts: meas:%i, mark:%i, gen:%i\n", dw->gl_ref_num_vertices, dw->gl_marker_num_vertices, dw->gl_gen_num_vertices);
src/glbits.c:	glOrtho(-aspect*(dw->distance/2.0), aspect*(dw->distance/2.0), -(dw->distance/2.0), (dw->distance/2.0), 0.001, 400.0);
src/glbits.c:	GLfloat w = dw->drawing_area->allocation.width;
src/glbits.c:	GLfloat h = dw->drawing_area->allocation.height;
src/glbits.c:	if ( dw->background ) {
src/glbits.c:	glTranslatef(dw->x_pos, -dw->y_pos, 400.0-dw->distance);
src/glbits.c:	build_rotmatrix(m, dw->view_quat);
src/glbits.c:	//dw->theta = atan2(m[2][0], m[2][1])*180.0/M_PI;								/*angles seem to work, now to output them usefully in the displaywindow!*/
src/glbits.c:	/*dw->phi = acos(m[2][2])*180.0/M_PI;
src/glbits.c:	dw->psi = atan2(m[0][2], m[1][2])*180.0/M_PI;
src/glbits.c:	printf("%f, %f, %f\n", dw->theta, dw->phi, dw->psi);*/
src/glbits.c:	if ( dw->mode == DW_MAPPED ) {
src/glbits.c:		if ( dw->gl_ref_num_vertices ) {
src/glbits.c:			if ( dw->gl_use_buffers ) {
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_ref_vertex_buffer);
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_ref_normal_buffer);
src/glbits.c:				glDrawArrays(GL_POINTS, 0, dw->gl_ref_num_vertices);
src/glbits.c:				glVertexPointer(3, GL_FLOAT, 0, dw->gl_ref_vertex_array);
src/glbits.c:				glNormalPointer(GL_FLOAT, 0, dw->gl_ref_normal_array);
src/glbits.c:				glDrawArrays(GL_POINTS, 0, dw->gl_ref_num_vertices);
src/glbits.c:		if ( dw->gl_marker_num_vertices ) {
src/glbits.c:			if ( dw->gl_use_buffers ) {
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_marker_vertex_buffer);
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_marker_normal_buffer);
src/glbits.c:				glDrawArrays(GL_QUADS, 0, dw->gl_marker_num_vertices);
src/glbits.c:				glVertexPointer(3, GL_FLOAT, 0, dw->gl_marker_vertex_array);
src/glbits.c:				glNormalPointer(GL_FLOAT, 0, dw->gl_marker_normal_array);
src/glbits.c:				glDrawArrays(GL_QUADS, 0, dw->gl_marker_num_vertices);
src/glbits.c:		if ( dw->gl_gen_num_vertices ) {
src/glbits.c:			if ( dw->gl_use_shaders ) glUseProgram(dw->gl_program_lightpp);
src/glbits.c:			if ( dw->gl_use_buffers ) {
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_gen_vertex_buffer);
src/glbits.c:				glBindBuffer(GL_ARRAY_BUFFER, dw->gl_gen_normal_buffer);
src/glbits.c:				glDrawArrays(GL_QUADS, 0, dw->gl_gen_num_vertices);
src/glbits.c:				glVertexPointer(3, GL_FLOAT, 0, dw->gl_gen_vertex_array);
src/glbits.c:				glNormalPointer(GL_FLOAT, 0, dw->gl_gen_normal_array);
src/glbits.c:				glDrawArrays(GL_QUADS, 0, dw->gl_gen_num_vertices);
src/glbits.c:			if ( dw->gl_use_shaders ) glUseProgram(0);
src/glbits.c:	if ( dw->lines && dw->gl_line_num_vertices ) {
src/glbits.c:		if ( dw->gl_use_buffers ) {
src/glbits.c:			glBindBuffer(GL_ARRAY_BUFFER, dw->gl_line_vertex_buffer);
src/glbits.c:			glDrawArrays(GL_LINES, 0, dw->gl_line_num_vertices);
src/glbits.c:			glVertexPointer(3, GL_FLOAT, 0, dw->gl_line_vertex_array);
src/glbits.c:			glDrawArrays(GL_LINES, 0, dw->gl_line_num_vertices);
src/glbits.c:	glCallList(dw->gl_list_id);
src/glbits.c:	if ( dw->view == DW_ORTHO ) {
src/glbits.c:	if ( dw->gl_use_buffers ) {
src/glbits.c:		glDeleteBuffers(1, &dw->gl_ref_vertex_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_ref_normal_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_marker_vertex_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_marker_normal_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_gen_vertex_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_gen_normal_buffer);
src/glbits.c:		glDeleteBuffers(1, &dw->gl_line_vertex_buffer);
src/glbits.c:		if ( dw->gl_ref_vertex_array != NULL ) free(dw->gl_ref_vertex_array);
src/glbits.c:		if ( dw->gl_ref_normal_array != NULL ) free(dw->gl_ref_normal_array);
src/glbits.c:		if ( dw->gl_marker_vertex_array != NULL ) free(dw->gl_marker_vertex_array);
src/glbits.c:		if ( dw->gl_marker_normal_array != NULL ) free(dw->gl_marker_normal_array);
src/glbits.c:		if ( dw->gl_gen_vertex_array != NULL ) free(dw->gl_gen_vertex_array);
src/glbits.c:		if ( dw->gl_gen_normal_array != NULL ) free(dw->gl_gen_normal_array);
src/glbits.c:		if ( dw->gl_line_vertex_array != NULL ) free(dw->gl_line_vertex_array);
src/glbits.c:	glDeleteLists(dw->gl_list_id, 1);
src/glbits.c:	if ( dw->gl_use_shaders ) glbits_delete_shaders(dw);
src/glbits.c:	if ( dw->gl_use_shaders ) glbits_load_shaders(dw);
src/glbits.c:	dw->realised = 1;
src/intensities.c:					GTK_WINDOW(ctx->dw->window),
src/refine.c:	ctx->images->images[ctx->dw->cur_image].rflist = NULL;
src/refinetest2d.c:	ctx->dw->cur_image = 0;
src/refinetest3d1.c:	ctx->dw->cur_image = 0;
src/refinetest3d2.c:	ctx->dw->cur_image = 0;
src/refinetest3d3.c:	ctx->dw->cur_image = 0;
